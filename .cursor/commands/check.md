# 백엔드-프론트엔드 엔티티 점검 가이드

## 점검 목적

백엔드 엔드포인트를 기준으로 프론트엔드 엔티티 훅의 일치 여부를 확인하고 수정

## 점검 대상

특정 도메인의 백엔드 엔드포인트와 프론트엔드 엔티티 훅

## 점검 절차

### 1단계: 백엔드 파일 확인

- 백엔드 컨트롤러 파일 읽기 (apps/api/src/endpoints/{도메인}/{도메인}.controller.ts)
- 백엔드 서비스 파일 읽기 (apps/api/src/endpoints/{도메인}/{도메인}.service.ts)
- 각 엔드포인트의 다음 정보 파악:
  - HTTP 메소드 (GET, POST, PUT, DELETE)
  - 요청 경로
  - 요청 데이터 타입 (DTO)
  - 응답 데이터 타입

### 2단계: 백엔드 DTO 및 스키마 확인

- 사용되는 DTO 파일 확인 (apps/api/src/dto/)
- DTO가 참조하는 스키마 파일 확인 (apps/api/src/endpoints/prisma/schemas/)
- 각 DTO의 필드 구성 파악

### 3단계: 프론트엔드 파일 확인

- 프론트엔드 훅 디렉토리 확인 (apps/ui/app/\_entities/{도메인}/hooks/)
- 각 훅 파일 읽기
- 프론트엔드 스키마 파일 확인 (apps/ui/app/\_schemas/{도메인}.schema.ts)

### 4단계: 비교 및 점검

다음 세 가지를 중점적으로 점검:

1. **요청 주소 일치 여부**

   - 백엔드 엔드포인트 경로와 프론트엔드 url 배열이 동일한가
   - 예: 백엔드 '/users/profile' = 프론트 ['users', 'profile']

2. **요청 메소드 일치 여부**

   - 백엔드 메소드(GET/POST/PUT/DELETE)와 프론트 사용 훅(useGet/usePost/usePut/useDelete)이 일치하는가

3. **요청/응답 데이터 형식 일치 여부**
   - 백엔드 DTO와 프론트엔드 스키마 타입의 필드가 동일한가
   - 백엔드 응답 타입과 프론트엔드 제네릭 타입이 일치하는가
   - 선택적 필드(optional) 여부가 동일한가

### 5단계: 불일치 발견 시 수정

**기본 원칙: 백엔드가 기준**

- 프론트엔드를 백엔드에 맞춰 수정
- 단, passwordConfirm 같은 프론트 validation 전용 필드는 예외

**수정 대상:**

- 프론트엔드 스키마에 백엔드 DTO 필드 추가/제거
- 프론트엔드 훅의 제네릭 타입 수정
- 프론트엔드 요청 주소 또는 메소드 수정

### 6단계: 점검 결과 정리

다음 형식으로 점검 결과 제공:

**정상 동작 항목:**

- 훅 이름 - 메소드 및 경로
- 요청 주소 일치 여부
- 요청 메소드 일치 여부
- 요청/응답 데이터 일치 여부

**문제 발견 항목:**

- 훅 이름 - 메소드 및 경로
- 구체적인 불일치 내용
- 수정 필요 사항

## 주의사항

- 백엔드 코드를 진실의 근원으로 취급
- 프론트엔드 validation 전용 필드(passwordConfirm 등)는 예외 처리
- Type과 Dto를 혼동하지 않기 (프로젝트는 둘 다 사용)
- 수정 후 린터 에러 확인 필수

## 특이사항: usePostQuery 훅

- 백엔드에서 메소드명이 get으로 시작하지만 HTTP 메소드는 POST인 경우가 존재
- 프론트엔드에서는 usePostQuery 커스텀 훅을 사용하여 처리
- usePostQuery는 React Query의 useQuery를 사용하지만 실제 요청은 axios.post로 전송
- 따라서 백엔드 POST 엔드포인트 = 프론트 usePostQuery 사용으로 매칭되는 경우가 있음
- 이런 경우 메소드 불일치로 판단하지 말고 정상으로 처리
